package com.kostmo.grouper.persistence;

import java.io.IOException;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.HashMap;
import java.util.Map;
import java.util.Properties;

import javax.servlet.http.HttpServlet;

import org.json.simple.JSONObject;

public class PostgresData {

	public static Connection getPostgresConnection(HttpServlet servlet) throws SQLException {
		
		Properties postgres_properties = new Properties();
		try {
			postgres_properties.load(servlet.getServletContext().getResourceAsStream("/WEB-INF/postgresql.properties"));
		} catch (IOException e) {
			e.printStackTrace();
		}
		
		return DriverManager.getConnection(postgres_properties.getProperty("jdbc_url"), postgres_properties);
	}

	// ========================================================================
	public static Map<Long, Group> loadGroups(Connection con, String username) throws SQLException {

		String query = "SELECT * FROM \"ViewGroupsWithAggregateInfo\" WHERE owner=? OR is_public";
		PreparedStatement query_statement = con.prepareStatement(query);
		query_statement.setString(1, username);

		Map<Long, Group> groups = new HashMap<Long, Group>();
		try {
			ResultSet rs = query_statement.executeQuery();
			while (rs.next()) {
				Group g = Group.newFromResultSet(rs);
				groups.put(g.id, g);
			}
		} catch (SQLException e ) {
			e.printStackTrace();
		} finally {
			if (query_statement != null) { query_statement.close(); }
		}
		
		return groups;
	}

	// ========================================================================
	public static Map<String, GroupMember> loadGroupMembers(Connection con, long group_id) throws SQLException {

		Map<String, GroupMember> group_members = new HashMap<String, GroupMember>();
		
		String query = "SELECT * FROM \"membership\" WHERE group_id=?";
		PreparedStatement query_statement = con.prepareStatement(query);
		try {
			query_statement.setLong(1, group_id);
			ResultSet rs = query_statement.executeQuery();
			while (rs.next()) {
				GroupMember member = GroupMember.newFromResultSet(rs);
				group_members.put(member.alias, member);
			}
		} catch (SQLException e ) {
			e.printStackTrace();
		} finally {
			if (query_statement != null) { query_statement.close(); }
		}
		
		return group_members;
	}

	// ========================================================================
	public static long copyGroup(Connection con, long source_group_id, String new_group_name, String new_owner) throws SQLException {

		// Makes sure source group is either public or owned by the current user
		PreparedStatement group_permission_statement = con.prepareStatement("SELECT is_public, owner FROM groups WHERE id=?");
		group_permission_statement.setLong(1, source_group_id);
		ResultSet rs = group_permission_statement.executeQuery();
		if (rs.next()) {
			boolean is_public = rs.getBoolean("is_public");
			String owner = rs.getString("owner").trim();
			System.out.println("Refusing to copy; user is not the owner and group is not public.");
			
			if ( !(owner.equals(new_owner) || is_public) )
			return -1;
			
		} else {
			System.out.println("Could not find source group.");
			return -1;
		}

		String group_insertion_query = "INSERT INTO \"groups\" (label, is_public, is_self_serve, owner) (SELECT ?, is_public, is_self_serve, ? FROM groups WHERE id=?)";
		PreparedStatement group_insertion_statement = con.prepareStatement(group_insertion_query, Statement.RETURN_GENERATED_KEYS);
		
		String member_insertion_query = "INSERT INTO \"membership\" (alias, group_id, set_by) (SELECT alias, ?, ? FROM membership WHERE group_id=?)";
		PreparedStatement member_insertion_statement = con.prepareStatement(member_insertion_query);

		group_insertion_statement.setString(1, new_group_name);
		group_insertion_statement.setString(2, new_owner);
		group_insertion_statement.setLong(3, source_group_id);
	
		
		long new_group_id = -2;
		try {

			int status = group_insertion_statement.executeUpdate();
			ResultSet rs2 = group_insertion_statement.getGeneratedKeys();
			while (rs2.next()) {
				new_group_id = rs.getLong(1);
				System.out.println("\tAutogenerated Key: " + new_group_id);
			}
		
			member_insertion_statement.setLong(1, new_group_id);
			member_insertion_statement.setString(2, new_owner);
			member_insertion_statement.setLong(3, source_group_id);
			
			int status2 = member_insertion_statement.executeUpdate();
	
		} catch (SQLException e ) {
			e.printStackTrace();
		} finally {
			if (group_insertion_statement != null) { group_insertion_statement.close(); }
			if (member_insertion_statement != null) { member_insertion_statement.close(); }
		}
		
		return new_group_id;
	}
	
	// ========================================================================
	public static long insertNewGroup(Connection con, JSONObject group_object, String owner_alias) throws SQLException {

		String group_insertion_query = "INSERT INTO \"groups\" (label, is_public, is_self_serve, owner) VALUES (?, ?, ?, ?)";
		PreparedStatement group_insertion_statement = con.prepareStatement(group_insertion_query, Statement.RETURN_GENERATED_KEYS);
		
		String member_insertion_query = "INSERT INTO \"membership\" (alias, group_id, set_by) VALUES (?, ?, ?)";
		PreparedStatement member_insertion_statement = con.prepareStatement(member_insertion_query);
		
		group_insertion_statement.setString(1, group_object.get("label").toString());
		group_insertion_statement.setBoolean(2, new Boolean( (Boolean) group_object.get("is_public") ));
		group_insertion_statement.setBoolean(3, new Boolean( (Boolean) group_object.get("is_self_serve") ));
		group_insertion_statement.setString(4, owner_alias);
		
		
		long group_id = -2;
		try {
			

			int status = group_insertion_statement.executeUpdate();
			
			ResultSet rs = group_insertion_statement.getGeneratedKeys();
			while (rs.next()) {
				group_id = rs.getLong(1);
				System.out.println("\tAutogenerated Key: " + group_id);
			}

			JSONObject members_as_dicts = (JSONObject) group_object.get("members_as_dicts");
			for (Object item_key : members_as_dicts.keySet()) {
				String alias = item_key.toString();

				member_insertion_statement.setString(1, alias);
				member_insertion_statement.setLong(2, group_id);
				member_insertion_statement.setString(3, owner_alias);
				
				int status2 = member_insertion_statement.executeUpdate();
			}
			
			
		} catch (SQLException e ) {
			e.printStackTrace();
		} finally {
			if (group_insertion_statement != null) { group_insertion_statement.close(); }
			if (member_insertion_statement != null) { member_insertion_statement.close(); }
		}
		
		return group_id;
	}
	
	// ========================================================================
	public static long deleteGroup(Connection con, long group_id) throws SQLException {

		String member_deletion_query = "DELETE FROM \"membership\" WHERE group_id=?";
		PreparedStatement member_deletion_statement = con.prepareStatement(member_deletion_query);
		
		String group_deletion_query = "DELETE FROM \"groups\" WHERE id=?";
		PreparedStatement group_deletion_statement = con.prepareStatement(group_deletion_query);
		
		try {
			
			member_deletion_statement.setLong(1, group_id);
			int status1 = member_deletion_statement.executeUpdate();
			

			group_deletion_statement.setLong(1, group_id);
			int status2 = group_deletion_statement.executeUpdate();
			
		} catch (SQLException e ) {
			e.printStackTrace();
		} finally {
			if (member_deletion_statement != null) { member_deletion_statement.close(); }
			if (group_deletion_statement != null) { group_deletion_statement.close(); }
		}
		
		return -1;
	}
}
